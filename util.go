package uuid

import (
	"crypto/rand"
	"errors"
	"io"
)

const upperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

const hexEncode = "0123456789abcdef"

var hexDecode = [256]byte{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x00 .. 0x07
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x08 .. 0x0f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x10 .. 0x17
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x18 .. 0x1f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x20 .. 0x27
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x28 .. 0x2f
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 0x30 .. 0x37
	0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x38 .. 0x3f
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, // 0x40 .. 0x47
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x48 .. 0x4f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x50 .. 0x57
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x58 .. 0x5f
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, // 0x60 .. 0x67
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x68 .. 0x6f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x70 .. 0x77
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x78 .. 0x7f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x80 .. 0x87
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x88 .. 0x8f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x90 .. 0x97
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x98 .. 0x9f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xa0 .. 0xa7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xa8 .. 0xaf
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xb0 .. 0xb7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xb8 .. 0xbf
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xc0 .. 0xc7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xc8 .. 0xcf
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xd0 .. 0xd7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xd8 .. 0xdf
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xe0 .. 0xe7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xe8 .. 0xef
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xf0 .. 0xf7
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0xf8 .. 0xff
}

func appendHexByte(out []byte, value byte) []byte {
	hi := (value >> 4)
	lo := (value & 0xf)
	return append(out, hexEncode[hi], hexEncode[lo])
}

func decodeHexByte(str string, si uint) (bool, byte) {
	hi := hexDecode[str[si]]
	lo := hexDecode[str[si+1]]
	if hi == 0xff || lo == 0xff {
		return false, 0
	}
	value := (hi << 4) | lo
	return true, value
}

func isHex(ch byte) bool {
	return hexDecode[ch] != 0xff
}

func readRandom(rng io.Reader, out []byte) error {
	if rng == nil {
		rng = rand.Reader
	}

	_, err := io.ReadFull(rng, out)
	return err
}

func isClockStorageUnavailable(err error) bool {
	var unavailable ClockStorageUnavailableError
	return errors.Is(err, &unavailable)
}

func parseImpl(str string, a, b, c, d, e uint) (UUID, error) {
	strIndex := [Size]uint{
		a + 0x0, a + 0x2, a + 0x4, a + 0x6,
		b + 0x0, b + 0x2, c + 0x0, c + 0x2,
		d + 0x0, d + 0x2, e + 0x0, e + 0x2,
		e + 0x4, e + 0x6, e + 0x8, e + 0xa,
	}

	var uuid UUID
	var ok [Size]bool
	for bi := uint(0); bi < Size; bi++ {
		si := strIndex[bi]
		ok[bi], uuid[bi] = decodeHexByte(str, si)
	}

	allZeroes := true
	allOnes := true
	for bi := uint(0); bi < Size; bi++ {
		if !ok[bi] {
			si := strIndex[bi]
			if isHex(str[si]) {
				si++
			}
			return NilUUID, ParseError{
				Input:   str,
				Problem: UnexpectedCharacter,
				Args:    []interface{}{si},
				Index:   si,
			}
		}
		allZeroes = allZeroes && (uuid[bi] == 0x00)
		allOnes = allOnes && (uuid[bi] == 0xff)
	}

	if !allZeroes && !allOnes && (uuid[8]&0xc0) != 0x80 {
		vb := uuid[8]
		return NilUUID, ParseError{
			Input:       str,
			Problem:     WrongVariant,
			Args:        []interface{}{vb},
			VariantByte: vb,
		}
	}

	return uuid, nil
}
